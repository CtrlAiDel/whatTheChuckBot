"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const Subcommand_1=require("../../../class/Subcommand");async function interactionPostUpdate(e,t){e.args;const n=e.interaction;e.client;var a=e.ephemerality,e=(t.length,await n.followUp({content:"Post IS UPDATED HERES THE RESULTS !!!!!!!!\n",ephemeral:a}));await n.channel.messages.fetch(e.id),n.fetchReply();for(const s of t);n.followUp({content:"Post is finnished !!!!!!!!",ephemeral:a})}async function mesgDeleterInterval(t,n){if(n<=0||n>=Number.MAX_SAFE_INTEGER){const e=new Error;throw e.message=`[${e.stack}]
Argument msInterval is out of range => number[0-maxSafeInt]`,e}return new Promise(async e=>{setTimeout(async()=>{e(await t.delete())},n)})}exports.default=new Subcommand_1.SubCommand(async c=>{const i=c.args,m=c.interaction;c.client;const u=new Subcommand_1.FollowUpObj;try{let t,n=0,a=0,e,s=0;const h=i.getUser("author",!0).username,d=i.getChannel("channel",!0);let o=await d.messages.fetch(),r=o.lastKey(),l=[];for(;0<o.size;)s===o.size&&(o=await d.messages.fetch({before:r}),r=o.lastKey(),s=0),o.forEach(e=>{t=e.author.username,s++,n++,a+=t===h?1:0,e.deletable&&t===h&&l.push(e)});e=l.length,0<a&&0<e?(u.reply={content:`I'm done! I'll be deleting: ${e}/${n} delay = 1x/sec. üòâ‚úîÔ∏è
                Dont forget to refresh the server your viewing by switching between servers.`},m.client.emit("debug",`CHANNEL ${d.name} IS BEING PURGED BY ${m.member.user.username} => channelID: ${d.id} numDelted: `+e)):0===n?u.reply={content:"I was unable to find any messages in this channel?! ü§î‚úîÔ∏è"}:0===a?u.reply={content:"No message found from this author! ü§î‚úîÔ∏è"}:0===e&&0<a?u.reply={content:`I was unable to delete any of the ${a} messages! ü§î‚ùå
Maybe check the permissions I have on your server???`}:e!==a&&(u.reply={content:`I was unable to delete ${a-e} of the messages! ü§î‚ùå`},m.client.emit("debug",`CHANNEL ${d.name} IS BEING PURGED BY ${m.member.user.username} => channelID: ${d.id} numDelted: `+e)),await m.editReply(u.reply),await interactionPostUpdate(c,l)}catch(e){return u.fromatOnError(e),void await m.followUp(u.reply)}});